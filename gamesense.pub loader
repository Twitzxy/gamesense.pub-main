local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Window = Library:CreateWindow({ Title = '                     $ Mad.lol | Beta $                     ', AutoShow = true, TabPadding = 15, MenuFadeTime = 0.2 })
local Tabs = { Main = Window:AddTab('Main'), ['UI Settings'] = Window:AddTab('UI Settings') }

local LocalPlayer = game:GetService('Players').LocalPlayer
local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Main Tab
local GunMods = Tabs.Main:AddRightGroupbox('Gun Mods')
local KillAura = Tabs.Main:AddRightGroupbox('Combat')
local TargetingGroup = Tabs.Main:AddLeftGroupbox('Targeting')
local Target = Tabs.Main:AddLeftGroupbox('Target')

-- Variables
local lockedTarget = nil
local StickyAimEnabled = false
local TracerEnabled = false
local ViewTargetEnabled = false
local targetHitPart = "Head"
local targetToMouseTracer = true
local grabCheckEnabled = true
local koCheckEnabled = true
local friendCheckEnabled = false
local strafeEnabled = false
local strafeMode = "Orbit"
local strafeSpeed = 5
local strafeXOffset = 5
local predictMovementEnabled = false
local stompTargetEnabled = false
local lastPosition = nil
local oldPosition = nil
local Core = nil
local BodyVelocity = nil
local PredicTvalue = 1
local hiddenBulletsEnabled = false
local spectateStrafeEnabled = false
local AutoAmmoEnabled = false
local strafeWasEnabledBeforeAmmoBuy = false

local tracer = Drawing.new("Line")
tracer.Visible = false
tracer.Thickness = 1
tracer.Color = Color3.fromRGB(255, 255, 255)

function predictPosition(targetRoot, predictionMultiplier)
    if not targetRoot then return targetRoot.Position end
    if targetRoot.Velocity.Magnitude > 700 then
        return targetRoot.Position
    end
    return targetRoot.Position + (targetRoot.Velocity * predictionMultiplier)
end

-- Sticky Aim
TargetingGroup:AddToggle("StickyAim", {
    Text = "Sticky Aim",
    Default = false,
    Callback = function(Value)
        StickyAimEnabled = Value
        if not Value then
            lockedTarget = nil
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
            tracer.Visible = false
        end
    end
}):AddKeyPicker("StickyAimKeybind", {
    Default = "C",
    NoUI = false,
    Text = "Sticky Aim",
    Mode = "Toggle",
    Callback = function()
        if UserInputService:GetFocusedTextBox() then return end
        if lockedTarget then
            lockedTarget = nil
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
            tracer.Visible = false
        else
            local camera = workspace.CurrentCamera
            local mouseLocation = UserInputService:GetMouseLocation()
            local closestTarget, closestDistance = nil, math.huge

            for _, otherPlayer in ipairs(Players:GetPlayers()) do
                if otherPlayer ~= LocalPlayer and otherPlayer.Character and otherPlayer.Character:FindFirstChild(targetHitPart) then
                    local bodyEffects = otherPlayer.Character:FindFirstChild("BodyEffects")
                    local isKO = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                    local isGrabbed = otherPlayer.Character:FindFirstChild("GRABBING_CONSTRAINT")

                    if (not grabCheckEnabled or not isGrabbed) and
                       (not friendCheckEnabled or not LocalPlayer:IsFriendsWith(otherPlayer.UserId)) then

                        local targetPart = otherPlayer.Character[targetHitPart]
                        local screenPosition, onScreen = camera:WorldToViewportPoint(targetPart.Position)
                        if onScreen then
                            local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mouseLocation).Magnitude
                            if distance < closestDistance then
                                closestTarget = otherPlayer
                                closestDistance = distance
                            end
                        end
                    end
                end
            end

            if closestTarget then
                lockedTarget = closestTarget
            end
        end
    end
})

-- Spectate
local maddieplsnomad = false
TargetingGroup:AddToggle("ViewTarget", {
    Text = "spectate",
    Default = false,
    Callback = function(Value)
        maddieplsnomad = Value
        if not Value then
            ViewTargetEnabled = false
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
        end
    end
}):AddKeyPicker("ViewTargetKeybind", {
    Default = "B",
    NoUI = false,
    Text = "spectate",
    Mode = "Toggle",
    Callback = function()
        if not maddieplsnomad or UserInputService:GetFocusedTextBox() then return end
        ViewTargetEnabled = not ViewTargetEnabled
        if ViewTargetEnabled and lockedTarget then
            workspace.CurrentCamera.CameraSubject = lockedTarget.Character
        else
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
        end
    end
})

-- Hit Part Selection
TargetingGroup:AddDropdown("hp", {
    Text = "Hit Part",
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"},
    Default = "Head",
    Callback = function(Value)
        targetHitPart = Value
    end
})

-- Target Strafe
Target:AddToggle("StrafeToggle", {
    Text = "Target Strafe",
    Default = false,
    Callback = function(Value)
        strafeEnabled = Value
        if not Value then
            if Core then
                Core:Destroy()
                Core = nil
            end
            if BodyVelocity then
                BodyVelocity:Destroy()
                BodyVelocity = nil
            end
            if oldPosition then
                LocalPlayer.Character.HumanoidRootPart.CFrame = oldPosition
                oldPosition = nil
            end
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
        end
    end
}):AddKeyPicker("StrafeKeybind", {
    Default = "N",
    NoUI = false,
    Text = "Strafe",
    Mode = "Toggle",
    Callback = function()
        if UserInputService:GetFocusedTextBox() then return end
        strafeEnabled = not strafeEnabled
        if not strafeEnabled then
            if Core then
                Core:Destroy()
                Core = nil
            end
            if BodyVelocity then
                BodyVelocity:Destroy()
                BodyVelocity = nil
            end
            if oldPosition then
                LocalPlayer.Character.HumanoidRootPart.CFrame = oldPosition
                oldPosition = nil
            end
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
        end
    end
})

-- Spectate Strafe
Target:AddToggle("SpectateStrafe", {
    Text = "Spectate Strafe",
    Default = false,
    Callback = function(Value)
        spectateStrafeEnabled = Value
        if not Value then
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
        end
    end
})

-- Strafe Mode
Target:AddDropdown("StrafeMode", {
    Text = "Strafe Mode",
    Values = {"Orbit", "Random"},
    Default = "Orbit",
    Callback = function(Value)
        strafeMode = Value
    end
})

-- Strafe Speed
Target:AddSlider("StrafeSpeed", {
    Text = "Speed units",
    Default = 5,
    Min = 1,
    Max = 20,
    Rounding = 1,
    Callback = function(Value)
        strafeSpeed = Value
    end
})

-- Strafe Offset
Target:AddSlider("StrafeXOffset", {
    Text = "z offset",
    Default = 5,
    Min = 1,
    Max = 20,
    Rounding = 1,
    Callback = function(Value)
        strafeXOffset = Value
    end
})

-- Movement Prediction
Target:AddToggle("PredictMovement", {
    Text = "predict movement",
    Default = false,
    Callback = function(Value)
        predictMovementEnabled = Value
    end
})

-- Prediction Distance
Target:AddSlider("StrafePredictionDistance", {
    Text = "movement prediction",
    Default = 0.3,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        PredicTvalue = Value
    end
})

-- Stomp Target
TargetingGroup:AddToggle("StompTarget", {
    Text = "Stomp Target",
    Default = false,
    Callback = function(Value)
        stompTargetEnabled = Value
    end
})

-- Hidden Bullets
TargetingGroup:AddToggle("HiddenBullets", {
    Text = "invisible bullets",
    Default = false,
    Callback = function(Value)
        hiddenBulletsEnabled = Value
    end
})

-- Auto Ammo
TargetingGroup:AddToggle("AutoAmmo", {
    Text = "Auto Ammo",
    Default = false,
    Callback = function(Value)
        AutoAmmoEnabled = Value
    end
})

-- Kill Say
local killSayEnabled = false
local killSayMessages = {
    "mad.lol is a free script and u die to it..", 
    "Must be hard without mad.lol ðŸ’”", 
    "Why aim when mad.lol does it for you?",
    "Bros not on mad.lol already ðŸ˜‚",
    "Cant be me icl",
    "cant win a hvh? maybe try /madlolhvh",
    "if u wanna win hop in /madlolhvh",
    "hey come on if u cant win get mad . lol",
    "how to win a hvh? step 1 get mad . lol"
}

TargetingGroup:AddToggle("killsay", { 
    Text = "Kill Say", 
    Default = false,
    Callback = function(Value)
        killSayEnabled = Value
    end
})

-- Rapid Fire
local RapidFireEnabled = false
local hyperFireEnabled = false
local modifiedTools = {}

local function rapidfire(tool)
    if not tool or not tool:FindFirstChild("GunScript") or modifiedTools[tool] then return end

    for _, v in ipairs(getconnections(tool.Activated)) do
        local funcinfo = debug.getinfo(v.Function)
        for i = 1, funcinfo.nups do
            local c, n = debug.getupvalue(v.Function, i)
            if type(c) == "number" then
                debug.setupvalue(v.Function, i, 0.0000000000001)
            end
        end
    end

    modifiedTools[tool] = true
end

local function onCharacterAdded(character)
    for _, tool in ipairs(character:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("Handle") then
            rapidfire(tool)
        end
    end

    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and child:FindFirstChild("Handle") then
            rapidfire(child)
        end
    end)
end

if LocalPlayer.Character then
    onCharacterAdded(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

GunMods:AddToggle("RapidFireToggle", {
    Text = "Rapid Fire",
    Default = false,
    Callback = function(Value)
        RapidFireEnabled = Value
        if Value then
            modifiedTools = {}
            if LocalPlayer.Character then
                onCharacterAdded(LocalPlayer.Character)
            end
        end
    end
})

-- Hyper Fire
local function updateHyperFire()
    for _, obj in ipairs(game:GetDescendants()) do
        if obj.Name == "ToleranceCooldown" and obj:IsA("ValueBase") then
            obj.Value = 0 
        end
    end
end

GunMods:AddToggle("HyperFireToggle", {
    Text = "Rapid Fire v2",
    Default = false,
    Callback = function(Value)
        hyperFireEnabled = Value
        updateHyperFire()
    end
})

game.DescendantAdded:Connect(function(obj)
    if obj.Name == "ToleranceCooldown" and obj:IsA("ValueBase") then
        obj.Value = hyperFireEnabled and 0 or 3
    end
end)

-- Hitbox Expander
local HBE = Tabs.Main:AddRightGroupbox('HBE')
local size = 10
local hitboxColor = Color3.new(0, 1, 1)
local visualizeHitbox = false
local hitboxExpanderEnabled = false

HBE:AddToggle('HitboxExpanderToggle', {
    Text = 'Hitbox Expander',
    Default = false,
    Callback = function(state)
        hitboxExpanderEnabled = state
        if not state then
            for _, Player in pairs(Players:GetPlayers()) do
                if Player ~= LocalPlayer and Player.Character then
                    resetCharacter(Player.Character)
                end
            end
        end
    end,
}):AddKeyPicker("FlightKeybindPicker", {
    Default = "L",
    Text = "Hitbox",
    Mode = "Toggle",
    Callback = function(state)
        if UserInputService:GetFocusedTextBox() then return end
        hitboxExpanderEnabled = state
        if not state then
            for _, Player in pairs(Players:GetPlayers()) do
                if Player ~= LocalPlayer and Player.Character then
                    resetCharacter(Player.Character)
                end
            end
        end
    end
})

HBE:AddSlider('HitboxSizeSlider', {
    Text = 'Hitbox Size',
    Default = 10,
    Min = 10,
    Max = 50,
    Rounding = 0,
    Callback = function(value)
        size = value
    end,
})

HBE:AddToggle('VisualizerToggle', {
    Text = 'Visualize',
    Default = false,
    Callback = function(state)
        visualizeHitbox = state
        if not state then
            for _, Player in pairs(Players:GetPlayers()) do
                if Player ~= LocalPlayer and Player.Character then
                    removeVisuals(Player.Character)
                end
            end
        end
    end,
}):AddColorPicker('HitboxColorPicker', {
    Text = 'Hitbox Color',
    Default = Color3.new(0, 1, 1),
    Callback = function(color)
        hitboxColor = color
    end,
})

local function removeVisuals(Character)
    if not Character then return end
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if HRP then
        local outline = HRP:FindFirstChild("HitboxOutline")
        if outline then outline:Destroy() end
        local glow = HRP:FindFirstChild("HitboxGlow")
        if glow then glow:Destroy() end
    end
end

local function resetCharacter(Character)
    if not Character then return end
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if HRP then
        HRP.Size = Vector3.new(2, 1, 2)
        HRP.Transparency = 1
        HRP.CanCollide = true
        removeVisuals(Character)
    end
end

local function handleCharacter(Character)
    if not Character or not hitboxExpanderEnabled then
        resetCharacter(Character)
        return
    end
    local HRP = Character:FindFirstChild("HumanoidRootPart") or Character:WaitForChild("HumanoidRootPart", 5)
    if not HRP then return end

    HRP.Size = Vector3.new(size, size, size)
    HRP.Transparency = 1
    HRP.CanCollide = false

    if visualizeHitbox then
        local outline = HRP:FindFirstChild("HitboxOutline")
        if not outline then
            outline = Instance.new("BoxHandleAdornment")
            outline.Name = "HitboxOutline"
            outline.Adornee = HRP
            outline.Size = HRP.Size
            outline.Transparency = 0.8
            outline.ZIndex = 10
            outline.AlwaysOnTop = true
            outline.Color3 = hitboxColor
            outline.Parent = HRP

            local glow = Instance.new("BoxHandleAdornment")
            glow.Name = "HitboxGlow"
            glow.Adornee = HRP
            glow.Size = HRP.Size + Vector3.new(0.1, 0.1, 0.1)
            glow.Transparency = 0.9
            glow.ZIndex = 9
            glow.AlwaysOnTop = true
            glow.Color3 = hitboxColor
            glow.Parent = HRP
        else
            outline.Size = HRP.Size
            outline.Color3 = hitboxColor
            local glow = HRP:FindFirstChild("HitboxGlow")
            if glow then
                glow.Size = HRP.Size + Vector3.new(0.1, 0.1, 0.1)
                glow.Color3 = hitboxColor
            end
        end
    else
        removeVisuals(Character)
    end
end

local function handlePlayer(Player)
    if Player == LocalPlayer then return end
    Player.CharacterAdded:Connect(function(Character)
        Character:WaitForChild("HumanoidRootPart")
        handleCharacter(Character)
    end)
    if Player.Character then
        handleCharacter(Player.Character)
    end
end

for _, Player in pairs(Players:GetPlayers()) do
    handlePlayer(Player)
end

Players.PlayerAdded:Connect(handlePlayer)

RunService.Heartbeat:Connect(function()
    if not hitboxExpanderEnabled then
        for _, Player in pairs(Players:GetPlayers()) do
            if Player ~= LocalPlayer and Player.Character then
                resetCharacter(Player.Character)
            end
        end
        return
    end
    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and Player.Character then
            handleCharacter(Player.Character)
        end
    end
end)

-- Kill Aura
getgenv().range = 250
getgenv().whitelist = {}
getgenv().tracer = Instance.new("Part")
getgenv().tracer.Size = Vector3.new(0.2, 0.2, 0.2)
getgenv().tracer.Material = Enum.Material.Neon
getgenv().tracer.Color = Color3.new(1, 0, 0)
getgenv().tracer.Transparency = 1
getgenv().tracer.Anchored = true
getgenv().tracer.CanCollide = false
getgenv().tracer.Parent = workspace

getgenv().enabled = false
getgenv().active = false
getgenv().visualizeEnabled = false
getgenv().silentEnabled = false
getgenv().lastHealth = {}

KillAura:AddToggle('MainToggle', {
    Text = 'Kill Aura',
    Default = false,
    Callback = function(state)
        getgenv().enabled = state
        if not state then
            getgenv().active = false
            getgenv().tracer.Transparency = 1
        end
    end
}):AddKeyPicker('Keybind', {
    Default = 'K',
    Text = 'kill aura',
    Mode = 'Toggle',
    Callback = function(state)
        if not getgenv().enabled or UserInputService:GetFocusedTextBox() then return end
        getgenv().active = state
    end
})

KillAura:AddSlider("Range", {
    Text = "Range",
    Default = 250,
    Min = 10,
    Max = 250,
    Rounding = 1,
    Callback = function(value)
        getgenv().range = value
    end
})

KillAura:AddToggle('Visualizer', {
    Text = 'Visualize',
    Default = false,
    Callback = function(state)
        getgenv().visualizeEnabled = state
    end
}):AddColorPicker('VisualizerColor', {
    Text = 'Visualizer Color',
    Default = Color3.new(1, 0, 0),
    Callback = function(value)
        getgenv().tracer.Color = value
    end
})

KillAura:AddToggle('Silent', {
    Text = 'Silent',
    Default = false,
    Callback = function(state)
        getgenv().silentEnabled = state
    end
})

KillAura:AddInput('wlb', {
    Default = '',
    Numeric = false,
    Finished = false,
    Text = 'Add/Remove Player',
    Tooltip = 'Type a name or display name to add/remove from whitelist',
    Placeholder = 'Player Name',
    Callback = function(input)
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Name == input or player.DisplayName == input then
                if getgenv().whitelist[player.Name] then
                    getgenv().whitelist[player.Name] = nil
                    Library:Notify(player.Name .. " removed from whitelist.", 2)
                else
                    getgenv().whitelist[player.Name] = true
                    Library:Notify(player.Name .. " added to whitelist.", 2)
                end
                return
            end
        end
        Library:Notify("Player not found.", 2)
    end,
    Autocomplete = function(input)
        local suggestions = {}
        for _, player in pairs(game.Players:GetPlayers()) do
            if string.find(string.lower(player.Name), string.lower(input)) or string.find(string.lower(player.DisplayName), string.lower(input)) then
                table.insert(suggestions, player.Name .. " (" .. player.DisplayName .. ")")
            end
        end
        return suggestions
    end
})

-- UI Settings Tab
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' }) 

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings() 
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' }) 

ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')

SaveManager:BuildConfigSection(Tabs['UI Settings']) 
ThemeManager:ApplyToTab(Tabs['UI Settings'])

-- Main render loop
RunService.RenderStepped:Connect(function()
    if lockedTarget and lockedTarget.Character then
        local targetPart = lockedTarget.Character:FindFirstChild(targetHitPart)
        local bodyEffects = lockedTarget.Character:FindFirstChild("BodyEffects")
        local isKO = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
        local isGrabbed = lockedTarget.Character:FindFirstChild("GRABBING_CONSTRAINT")

        if ViewTargetEnabled then
            workspace.CurrentCamera.CameraSubject = lockedTarget.Character
        elseif spectateStrafeEnabled and strafeEnabled then
            workspace.CurrentCamera.CameraSubject = lockedTarget.Character:FindFirstChild("Head")
        end

        if strafeEnabled and targetPart and not isGrabbed then
            local targetRoot = lockedTarget.Character:FindFirstChild("HumanoidRootPart")
            local targetPosition = targetRoot.Position

            if predictMovementEnabled then
                targetPosition = predictPosition(targetRoot, PredicTvalue)
            end

            if strafeMode == "Orbit" then
                local angle = tick() * strafeSpeed
                local offset = Vector3.new(math.cos(angle) * strafeXOffset, -0.1, math.sin(angle) * strafeXOffset)
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition + offset, targetPosition)
            elseif strafeMode == "Random" then
                local offset = Vector3.new(math.random(-20, 20), math.random(-10, 10), math.random(-20, 20))
                local randomrotation = CFrame.Angles(
                    math.rad(math.random(0, 360)),
                    math.rad(math.random(0, 360)),
                    math.rad(math.random(0, 360))
                )
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition + offset) * randomrotation
            end
        end

        if TracerEnabled and targetPart then
            tracer.Visible = true
            local camera = workspace.CurrentCamera
            local targetScreenPos, onScreen = camera:WorldToViewportPoint(targetPart.Position)
            local endScreenPos

            if targetToMouseTracer then
                endScreenPos = UserInputService:GetMouseLocation()
            else
                local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local rootScreenPos, rootOnScreen = camera:WorldToViewportPoint(rootPart.Position)
                    if rootOnScreen then
                        endScreenPos = Vector2.new(rootScreenPos.X, rootScreenPos.Y)
                    end
                end
            end

            if onScreen and endScreenPos then
                tracer.From = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
                tracer.To = endScreenPos
            else
                tracer.Visible = false
            end
        else
            tracer.Visible = false
        end

        local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
        local handle = tool and tool:FindFirstChild("Handle")
        if tool and handle and targetPart and not isKO and not isGrabbed then
            if hiddenBulletsEnabled then
                ReplicatedStorage.MainEvent:FireServer(
                    "ShootGun",
                    handle,
                    handle.CFrame.Position - Vector3.new(0, 10, 0),
                    targetPart.Position - Vector3.new(0, 10, 0),
                    targetPart,
                    Vector3.new(0, 0, -1))
            else
                ReplicatedStorage.MainEvent:FireServer(
                    "ShootGun",
                    handle,
                    handle.CFrame.Position,
                    targetPart.Position,
                    targetPart,
                    Vector3.new(0, 0, -1))
            end
        end
    else
        tracer.Visible = false
    end
end)

-- Kill Aura loop
task.spawn(function()
    while true do
        if getgenv().active and getgenv().enabled and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle") then
            if workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild(game.Players.LocalPlayer.Name) and workspace.Players:FindFirstChild(game.Players.LocalPlayer.Name):FindFirstChild("BodyEffects") and workspace.Players:FindFirstChild(game.Players.LocalPlayer.Name).BodyEffects:FindFirstChild("K.O") and workspace.Players:FindFirstChild(game.Players.LocalPlayer.Name).BodyEffects["K.O"].Value then
                task.wait()
            else
                local closest = math.huge
                target = nil

                for _, player in pairs(game.Players:GetPlayers()) do
                    if player ~= game.Players.LocalPlayer and not getgenv().whitelist[player.Name] and player.Character and player.Character:FindFirstChild("Head") and not player.Character:FindFirstChild("GRABBING_CONSTRAINT") then
                        if workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild(player.Name) and workspace.Players:FindFirstChild(player.Name):FindFirstChild("BodyEffects") and workspace.Players:FindFirstChild(player.Name).BodyEffects:FindFirstChild("K.O") and not workspace.Players:FindFirstChild(player.Name).BodyEffects["K.O"].Value then
                            local dist = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - player.Character.Head.Position).Magnitude
                            if dist < closest and dist <= getgenv().range then
                                closest = dist
                                target = player
                            end
                        end
                    end
                end

                if target and target.Character and target.Character:FindFirstChild("Head") then
                    if getgenv().visualizeEnabled then
                        getgenv().tracer.Transparency = 0
                        getgenv().tracer.Size = Vector3.new(0.2, 0.2, (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - target.Character.Head.Position).Magnitude)
                        getgenv().tracer.CFrame = CFrame.lookAt(game.Players.LocalPlayer.Character.HumanoidRootPart.Position, target.Character.Head.Position) * CFrame.new(0, 0, -getgenv().tracer.Size.Z / 2)
                    else
                        getgenv().tracer.Transparency = 1
                    end

                    if getgenv().silentEnabled then
                        game.ReplicatedStorage.MainEvent:FireServer(
                            "ShootGun",
                            game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle"),
                            game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle").CFrame.Position - Vector3.new(0, 12, 0),
                            target.Character.Head.Position - Vector3.new(0, 12, 0),
                            target.Character.Head,
                            Vector3.new(0, 0, -1)
                        )
                    else
                        game.ReplicatedStorage.MainEvent:FireServer("ShootGun", game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle"), game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle").CFrame.Position, target.Character.Head.Position, target.Character.Head, Vector3.new(0, 0, -1))
                    end
                else
                    getgenv().tracer.Transparency = 1
                end
            end
        else
            getgenv().tracer.Transparency = 1
        end
        task.wait()
    end
end)

-- Stomp loop
task.spawn(function()
    while true do
        if stompTargetEnabled and lockedTarget and lockedTarget ~= LocalPlayer then
            local character = lockedTarget.Character
            if character then
                local bodyEffects = character:FindFirstChild("BodyEffects")
                local isKO = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                local isSDeath = bodyEffects and bodyEffects:FindFirstChild("SDeath") and bodyEffects["SDeath"].Value

                if isKO and not isSDeath then
                    local upperTorso = character:FindFirstChild("UpperTorso")
                    if upperTorso then
                        local humanoidRootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
                        if not lastPosition then
                            lastPosition = humanoidRootPart.Position
                        end
                        humanoidRootPart.CFrame = CFrame.new(upperTorso.Position + Vector3.new(0, 3, 0))
                        RunService.RenderStepped:Wait()
                    end
                elseif isSDeath and lastPosition then
                    if killSayEnabled then
                        local message = killSayMessages[math.random(1, #killSayMessages)]
                        game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message, "All")
                    end
                    local humanoidRootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
                    while (humanoidRootPart.Position - lastPosition).Magnitude > 5 do
                        humanoidRootPart.CFrame = CFrame.new(lastPosition)
                        task.wait()
                    end
                    lastPosition = nil
                end
            else
                if lastPosition then
                    local humanoidRootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
                    while (humanoidRootPart.Position - lastPosition).Magnitude > 5 do
                        humanoidRootPart.CFrame = CFrame.new(lastPosition)
                        task.wait()
                    end
                    lastPosition = nil
                end
            end
            ReplicatedStorage.MainEvent:FireServer("Stomp")
        end
        task.wait(0)
    end
end)
